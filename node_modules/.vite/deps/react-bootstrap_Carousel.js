"use client";
import {
  TransitionWrapper_default,
  require_classnames,
  transitionEndListener,
  triggerBrowserReflow,
  useBootstrapPrefix,
  useIsRTL,
  useUncontrolled
} from "./chunk-FUGH3NWB.js";
import {
  require_jsx_runtime
} from "./chunk-MJNCUEZK.js";
import "./chunk-HE4GKDYE.js";
import {
  require_react
} from "./chunk-UGC3UZ7L.js";
import {
  __toESM
} from "./chunk-G3PMV62Z.js";

// node_modules/@restart/hooks/esm/useEventCallback.js
var import_react2 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useCommittedRef.js
var import_react = __toESM(require_react());
function useCommittedRef(value) {
  const ref = (0, import_react.useRef)(value);
  (0, import_react.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
var useCommittedRef_default = useCommittedRef;

// node_modules/@restart/hooks/esm/useEventCallback.js
function useEventCallback(fn) {
  const ref = useCommittedRef_default(fn);
  return (0, import_react2.useCallback)(function(...args) {
    return ref.current && ref.current(...args);
  }, [ref]);
}

// node_modules/@restart/hooks/esm/useUpdateEffect.js
var import_react3 = __toESM(require_react());
function useUpdateEffect(fn, deps) {
  const isFirst = (0, import_react3.useRef)(true);
  (0, import_react3.useEffect)(() => {
    if (isFirst.current) {
      isFirst.current = false;
      return;
    }
    return fn();
  }, deps);
}
var useUpdateEffect_default = useUpdateEffect;

// node_modules/@restart/hooks/esm/useTimeout.js
var import_react7 = __toESM(require_react());

// node_modules/@restart/hooks/esm/useMounted.js
var import_react4 = __toESM(require_react());
function useMounted() {
  const mounted = (0, import_react4.useRef)(true);
  const isMounted = (0, import_react4.useRef)(() => mounted.current);
  (0, import_react4.useEffect)(() => {
    mounted.current = true;
    return () => {
      mounted.current = false;
    };
  }, []);
  return isMounted.current;
}

// node_modules/@restart/hooks/esm/useUpdatedRef.js
var import_react5 = __toESM(require_react());
function useUpdatedRef(value) {
  const valueRef = (0, import_react5.useRef)(value);
  valueRef.current = value;
  return valueRef;
}

// node_modules/@restart/hooks/esm/useWillUnmount.js
var import_react6 = __toESM(require_react());
function useWillUnmount(fn) {
  const onUnmount = useUpdatedRef(fn);
  (0, import_react6.useEffect)(() => () => onUnmount.current(), []);
}

// node_modules/@restart/hooks/esm/useTimeout.js
var MAX_DELAY_MS = 2 ** 31 - 1;
function setChainedTimeout(handleRef, fn, timeoutAtMs) {
  const delayMs = timeoutAtMs - Date.now();
  handleRef.current = delayMs <= MAX_DELAY_MS ? setTimeout(fn, delayMs) : setTimeout(() => setChainedTimeout(handleRef, fn, timeoutAtMs), MAX_DELAY_MS);
}
function useTimeout() {
  const isMounted = useMounted();
  const handleRef = (0, import_react7.useRef)();
  useWillUnmount(() => clearTimeout(handleRef.current));
  return (0, import_react7.useMemo)(() => {
    const clear = () => clearTimeout(handleRef.current);
    function set(fn, delayMs = 0) {
      if (!isMounted()) return;
      clear();
      if (delayMs <= MAX_DELAY_MS) {
        handleRef.current = setTimeout(fn, delayMs);
      } else {
        setChainedTimeout(handleRef, fn, Date.now() + delayMs);
      }
    }
    return {
      set,
      clear,
      handleRef
    };
  }, []);
}

// node_modules/@restart/ui/esm/Anchor.js
var React2 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useCallbackRef.js
var import_react8 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useCommittedRef.js
var import_react9 = __toESM(require_react());
function useCommittedRef2(value) {
  const ref = (0, import_react9.useRef)(value);
  (0, import_react9.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}
var useCommittedRef_default2 = useCommittedRef2;

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useEventCallback.js
var import_react10 = __toESM(require_react());
function useEventCallback2(fn) {
  const ref = useCommittedRef_default2(fn);
  return (0, import_react10.useCallback)(function(...args) {
    return ref.current && ref.current(...args);
  }, [ref]);
}

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useEventListener.js
var import_react11 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useGlobalListener.js
var import_react12 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useInterval.js
var import_react13 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useRafInterval.js
var import_react14 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useMergeState.js
var import_react15 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useMounted.js
var import_react16 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/usePrevious.js
var import_react17 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useImage.js
var import_react18 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useResizeObserver.js
var import_react20 = __toESM(require_react());

// node_modules/@restart/ui/node_modules/@restart/hooks/esm/useIsomorphicEffect.js
var import_react19 = __toESM(require_react());
var isReactNative = typeof global !== "undefined" && // @ts-ignore
global.navigator && // @ts-ignore
global.navigator.product === "ReactNative";

// node_modules/@restart/ui/esm/Button.js
var React = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var _excluded = ["as", "disabled"];
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}
function isTrivialHref(href) {
  return !href || href.trim() === "#";
}
function useButtonProps({
  tagName,
  disabled,
  href,
  target,
  rel,
  role,
  onClick,
  tabIndex = 0,
  type
}) {
  if (!tagName) {
    if (href != null || target != null || rel != null) {
      tagName = "a";
    } else {
      tagName = "button";
    }
  }
  const meta = {
    tagName
  };
  if (tagName === "button") {
    return [{
      type: type || "button",
      disabled
    }, meta];
  }
  const handleClick = (event) => {
    if (disabled || tagName === "a" && isTrivialHref(href)) {
      event.preventDefault();
    }
    if (disabled) {
      event.stopPropagation();
      return;
    }
    onClick == null ? void 0 : onClick(event);
  };
  const handleKeyDown = (event) => {
    if (event.key === " ") {
      event.preventDefault();
      handleClick(event);
    }
  };
  if (tagName === "a") {
    href || (href = "#");
    if (disabled) {
      href = void 0;
    }
  }
  return [{
    role: role != null ? role : "button",
    // explicitly undefined so that it overrides the props disabled in a spread
    // e.g. <Tag {...props} {...hookProps} />
    disabled: void 0,
    tabIndex: disabled ? void 0 : tabIndex,
    href,
    target: tagName === "a" ? target : void 0,
    "aria-disabled": !disabled ? void 0 : disabled,
    rel: tagName === "a" ? rel : void 0,
    onClick: handleClick,
    onKeyDown: handleKeyDown
  }, meta];
}
var Button = React.forwardRef((_ref, ref) => {
  let {
    as: asProp,
    disabled
  } = _ref, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  const [buttonProps, {
    tagName: Component
  }] = useButtonProps(Object.assign({
    tagName: asProp,
    disabled
  }, props));
  return (0, import_jsx_runtime.jsx)(Component, Object.assign({}, props, buttonProps, {
    ref
  }));
});
Button.displayName = "Button";

// node_modules/@restart/ui/esm/Anchor.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime());
var _excluded2 = ["onKeyDown"];
function _objectWithoutPropertiesLoose2(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (e.indexOf(n) >= 0) continue;
    t[n] = r[n];
  }
  return t;
}
function isTrivialHref2(href) {
  return !href || href.trim() === "#";
}
var Anchor = React2.forwardRef((_ref, ref) => {
  let {
    onKeyDown
  } = _ref, props = _objectWithoutPropertiesLoose2(_ref, _excluded2);
  const [buttonProps] = useButtonProps(Object.assign({
    tagName: "a"
  }, props));
  const handleKeyDown = useEventCallback2((e) => {
    buttonProps.onKeyDown(e);
    onKeyDown == null ? void 0 : onKeyDown(e);
  });
  if (isTrivialHref2(props.href) || props.role === "button") {
    return (0, import_jsx_runtime2.jsx)("a", Object.assign({
      ref
    }, props, buttonProps, {
      onKeyDown: handleKeyDown
    }));
  }
  return (0, import_jsx_runtime2.jsx)("a", Object.assign({
    ref
  }, props, {
    onKeyDown
  }));
});
Anchor.displayName = "Anchor";
var Anchor_default = Anchor;

// node_modules/react-bootstrap/esm/Carousel.js
var import_classnames3 = __toESM(require_classnames());
var React6 = __toESM(require_react());
var import_react21 = __toESM(require_react());

// node_modules/react-bootstrap/esm/CarouselCaption.js
var React3 = __toESM(require_react());
var import_classnames = __toESM(require_classnames());
var import_jsx_runtime3 = __toESM(require_jsx_runtime());
var CarouselCaption = React3.forwardRef(({
  className,
  bsPrefix,
  as: Component = "div",
  ...props
}, ref) => {
  bsPrefix = useBootstrapPrefix(bsPrefix, "carousel-caption");
  return (0, import_jsx_runtime3.jsx)(Component, {
    ref,
    className: (0, import_classnames.default)(className, bsPrefix),
    ...props
  });
});
CarouselCaption.displayName = "CarouselCaption";
var CarouselCaption_default = CarouselCaption;

// node_modules/react-bootstrap/esm/CarouselItem.js
var import_classnames2 = __toESM(require_classnames());
var React4 = __toESM(require_react());
var import_jsx_runtime4 = __toESM(require_jsx_runtime());
var CarouselItem = React4.forwardRef(({
  // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
  as: Component = "div",
  bsPrefix,
  className,
  ...props
}, ref) => {
  const finalClassName = (0, import_classnames2.default)(className, useBootstrapPrefix(bsPrefix, "carousel-item"));
  return (0, import_jsx_runtime4.jsx)(Component, {
    ref,
    ...props,
    className: finalClassName
  });
});
CarouselItem.displayName = "CarouselItem";
var CarouselItem_default = CarouselItem;

// node_modules/react-bootstrap/esm/ElementChildren.js
var React5 = __toESM(require_react());
function map(children, func) {
  let index = 0;
  return React5.Children.map(children, (child) => React5.isValidElement(child) ? func(child, index++) : child);
}
function forEach(children, func) {
  let index = 0;
  React5.Children.forEach(children, (child) => {
    if (React5.isValidElement(child)) func(child, index++);
  });
}

// node_modules/react-bootstrap/esm/Carousel.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime());
var import_jsx_runtime6 = __toESM(require_jsx_runtime());
var import_jsx_runtime7 = __toESM(require_jsx_runtime());
var SWIPE_THRESHOLD = 40;
function isVisible(element) {
  if (!element || !element.style || !element.parentNode || !element.parentNode.style) {
    return false;
  }
  const elementStyle = getComputedStyle(element);
  return elementStyle.display !== "none" && elementStyle.visibility !== "hidden" && getComputedStyle(element.parentNode).display !== "none";
}
var Carousel = (
  // eslint-disable-next-line react/display-name
  React6.forwardRef(({
    defaultActiveIndex = 0,
    ...uncontrolledProps
  }, ref) => {
    const {
      // Need to define the default "as" during prop destructuring to be compatible with styled-components github.com/react-bootstrap/react-bootstrap/issues/3595
      as: Component = "div",
      bsPrefix,
      slide = true,
      fade = false,
      controls = true,
      indicators = true,
      indicatorLabels = [],
      activeIndex,
      onSelect,
      onSlide,
      onSlid,
      interval = 5e3,
      keyboard = true,
      onKeyDown,
      pause = "hover",
      onMouseOver,
      onMouseOut,
      wrap = true,
      touch = true,
      onTouchStart,
      onTouchMove,
      onTouchEnd,
      prevIcon = (0, import_jsx_runtime5.jsx)("span", {
        "aria-hidden": "true",
        className: "carousel-control-prev-icon"
      }),
      prevLabel = "Previous",
      nextIcon = (0, import_jsx_runtime5.jsx)("span", {
        "aria-hidden": "true",
        className: "carousel-control-next-icon"
      }),
      nextLabel = "Next",
      variant,
      className,
      children,
      ...props
    } = useUncontrolled({
      defaultActiveIndex,
      ...uncontrolledProps
    }, {
      activeIndex: "onSelect"
    });
    const prefix = useBootstrapPrefix(bsPrefix, "carousel");
    const isRTL = useIsRTL();
    const nextDirectionRef = (0, import_react21.useRef)(null);
    const [direction, setDirection] = (0, import_react21.useState)("next");
    const [paused, setPaused] = (0, import_react21.useState)(false);
    const [isSliding, setIsSliding] = (0, import_react21.useState)(false);
    const [renderedActiveIndex, setRenderedActiveIndex] = (0, import_react21.useState)(activeIndex || 0);
    (0, import_react21.useEffect)(() => {
      if (!isSliding && activeIndex !== renderedActiveIndex) {
        if (nextDirectionRef.current) {
          setDirection(nextDirectionRef.current);
        } else {
          setDirection((activeIndex || 0) > renderedActiveIndex ? "next" : "prev");
        }
        if (slide) {
          setIsSliding(true);
        }
        setRenderedActiveIndex(activeIndex || 0);
      }
    }, [activeIndex, isSliding, renderedActiveIndex, slide]);
    (0, import_react21.useEffect)(() => {
      if (nextDirectionRef.current) {
        nextDirectionRef.current = null;
      }
    });
    let numChildren = 0;
    let activeChildInterval;
    forEach(children, (child, index) => {
      ++numChildren;
      if (index === activeIndex) {
        activeChildInterval = child.props.interval;
      }
    });
    const activeChildIntervalRef = useCommittedRef_default(activeChildInterval);
    const prev = (0, import_react21.useCallback)((event) => {
      if (isSliding) {
        return;
      }
      let nextActiveIndex = renderedActiveIndex - 1;
      if (nextActiveIndex < 0) {
        if (!wrap) {
          return;
        }
        nextActiveIndex = numChildren - 1;
      }
      nextDirectionRef.current = "prev";
      onSelect == null || onSelect(nextActiveIndex, event);
    }, [isSliding, renderedActiveIndex, onSelect, wrap, numChildren]);
    const next = useEventCallback((event) => {
      if (isSliding) {
        return;
      }
      let nextActiveIndex = renderedActiveIndex + 1;
      if (nextActiveIndex >= numChildren) {
        if (!wrap) {
          return;
        }
        nextActiveIndex = 0;
      }
      nextDirectionRef.current = "next";
      onSelect == null || onSelect(nextActiveIndex, event);
    });
    const elementRef = (0, import_react21.useRef)();
    (0, import_react21.useImperativeHandle)(ref, () => ({
      element: elementRef.current,
      prev,
      next
    }));
    const nextWhenVisible = useEventCallback(() => {
      if (!document.hidden && isVisible(elementRef.current)) {
        if (isRTL) {
          prev();
        } else {
          next();
        }
      }
    });
    const slideDirection = direction === "next" ? "start" : "end";
    useUpdateEffect_default(() => {
      if (slide) {
        return;
      }
      onSlide == null || onSlide(renderedActiveIndex, slideDirection);
      onSlid == null || onSlid(renderedActiveIndex, slideDirection);
    }, [renderedActiveIndex]);
    const orderClassName = `${prefix}-item-${direction}`;
    const directionalClassName = `${prefix}-item-${slideDirection}`;
    const handleEnter = (0, import_react21.useCallback)((node) => {
      triggerBrowserReflow(node);
      onSlide == null || onSlide(renderedActiveIndex, slideDirection);
    }, [onSlide, renderedActiveIndex, slideDirection]);
    const handleEntered = (0, import_react21.useCallback)(() => {
      setIsSliding(false);
      onSlid == null || onSlid(renderedActiveIndex, slideDirection);
    }, [onSlid, renderedActiveIndex, slideDirection]);
    const handleKeyDown = (0, import_react21.useCallback)((event) => {
      if (keyboard && !/input|textarea/i.test(event.target.tagName)) {
        switch (event.key) {
          case "ArrowLeft":
            event.preventDefault();
            if (isRTL) {
              next(event);
            } else {
              prev(event);
            }
            return;
          case "ArrowRight":
            event.preventDefault();
            if (isRTL) {
              prev(event);
            } else {
              next(event);
            }
            return;
          default:
        }
      }
      onKeyDown == null || onKeyDown(event);
    }, [keyboard, onKeyDown, prev, next, isRTL]);
    const handleMouseOver = (0, import_react21.useCallback)((event) => {
      if (pause === "hover") {
        setPaused(true);
      }
      onMouseOver == null || onMouseOver(event);
    }, [pause, onMouseOver]);
    const handleMouseOut = (0, import_react21.useCallback)((event) => {
      setPaused(false);
      onMouseOut == null || onMouseOut(event);
    }, [onMouseOut]);
    const touchStartXRef = (0, import_react21.useRef)(0);
    const touchDeltaXRef = (0, import_react21.useRef)(0);
    const touchUnpauseTimeout = useTimeout();
    const handleTouchStart = (0, import_react21.useCallback)((event) => {
      touchStartXRef.current = event.touches[0].clientX;
      touchDeltaXRef.current = 0;
      if (pause === "hover") {
        setPaused(true);
      }
      onTouchStart == null || onTouchStart(event);
    }, [pause, onTouchStart]);
    const handleTouchMove = (0, import_react21.useCallback)((event) => {
      if (event.touches && event.touches.length > 1) {
        touchDeltaXRef.current = 0;
      } else {
        touchDeltaXRef.current = event.touches[0].clientX - touchStartXRef.current;
      }
      onTouchMove == null || onTouchMove(event);
    }, [onTouchMove]);
    const handleTouchEnd = (0, import_react21.useCallback)((event) => {
      if (touch) {
        const touchDeltaX = touchDeltaXRef.current;
        if (Math.abs(touchDeltaX) > SWIPE_THRESHOLD) {
          if (touchDeltaX > 0) {
            prev(event);
          } else {
            next(event);
          }
        }
      }
      if (pause === "hover") {
        touchUnpauseTimeout.set(() => {
          setPaused(false);
        }, interval || void 0);
      }
      onTouchEnd == null || onTouchEnd(event);
    }, [touch, pause, prev, next, touchUnpauseTimeout, interval, onTouchEnd]);
    const shouldPlay = interval != null && !paused && !isSliding;
    const intervalHandleRef = (0, import_react21.useRef)();
    (0, import_react21.useEffect)(() => {
      var _ref, _activeChildIntervalR;
      if (!shouldPlay) {
        return void 0;
      }
      const nextFunc = isRTL ? prev : next;
      intervalHandleRef.current = window.setInterval(document.visibilityState ? nextWhenVisible : nextFunc, (_ref = (_activeChildIntervalR = activeChildIntervalRef.current) != null ? _activeChildIntervalR : interval) != null ? _ref : void 0);
      return () => {
        if (intervalHandleRef.current !== null) {
          clearInterval(intervalHandleRef.current);
        }
      };
    }, [shouldPlay, prev, next, activeChildIntervalRef, interval, nextWhenVisible, isRTL]);
    const indicatorOnClicks = (0, import_react21.useMemo)(() => indicators && Array.from({
      length: numChildren
    }, (_, index) => (event) => {
      onSelect == null || onSelect(index, event);
    }), [indicators, numChildren, onSelect]);
    return (0, import_jsx_runtime6.jsxs)(Component, {
      ref: elementRef,
      ...props,
      onKeyDown: handleKeyDown,
      onMouseOver: handleMouseOver,
      onMouseOut: handleMouseOut,
      onTouchStart: handleTouchStart,
      onTouchMove: handleTouchMove,
      onTouchEnd: handleTouchEnd,
      className: (0, import_classnames3.default)(className, prefix, slide && "slide", fade && `${prefix}-fade`, variant && `${prefix}-${variant}`),
      children: [indicators && (0, import_jsx_runtime5.jsx)("div", {
        className: `${prefix}-indicators`,
        children: map(children, (_, index) => (0, import_jsx_runtime5.jsx)("button", {
          type: "button",
          "data-bs-target": "",
          "aria-label": indicatorLabels != null && indicatorLabels.length ? indicatorLabels[index] : `Slide ${index + 1}`,
          className: index === renderedActiveIndex ? "active" : void 0,
          onClick: indicatorOnClicks ? indicatorOnClicks[index] : void 0,
          "aria-current": index === renderedActiveIndex
        }, index))
      }), (0, import_jsx_runtime5.jsx)("div", {
        className: `${prefix}-inner`,
        children: map(children, (child, index) => {
          const isActive = index === renderedActiveIndex;
          return slide ? (0, import_jsx_runtime5.jsx)(TransitionWrapper_default, {
            in: isActive,
            onEnter: isActive ? handleEnter : void 0,
            onEntered: isActive ? handleEntered : void 0,
            addEndListener: transitionEndListener,
            children: (status, innerProps) => React6.cloneElement(child, {
              ...innerProps,
              className: (0, import_classnames3.default)(child.props.className, isActive && status !== "entered" && orderClassName, (status === "entered" || status === "exiting") && "active", (status === "entering" || status === "exiting") && directionalClassName)
            })
          }) : React6.cloneElement(child, {
            className: (0, import_classnames3.default)(child.props.className, isActive && "active")
          });
        })
      }), controls && (0, import_jsx_runtime6.jsxs)(import_jsx_runtime7.Fragment, {
        children: [(wrap || activeIndex !== 0) && (0, import_jsx_runtime6.jsxs)(Anchor_default, {
          className: `${prefix}-control-prev`,
          onClick: prev,
          children: [prevIcon, prevLabel && (0, import_jsx_runtime5.jsx)("span", {
            className: "visually-hidden",
            children: prevLabel
          })]
        }), (wrap || activeIndex !== numChildren - 1) && (0, import_jsx_runtime6.jsxs)(Anchor_default, {
          className: `${prefix}-control-next`,
          onClick: next,
          children: [nextIcon, nextLabel && (0, import_jsx_runtime5.jsx)("span", {
            className: "visually-hidden",
            children: nextLabel
          })]
        })]
      })]
    });
  })
);
Carousel.displayName = "Carousel";
var Carousel_default = Object.assign(Carousel, {
  Caption: CarouselCaption_default,
  Item: CarouselItem_default
});
export {
  Carousel_default as default
};
//# sourceMappingURL=react-bootstrap_Carousel.js.map
